# 'Ransomware' decryptor!

This comes as an ELF file and a flag.enc, which is an encrypted file containing a flag, after being stuck with ransomware!

Taking a look at the .enc file with a hex editor, to see if there are any opportunities for a quick win, or to spot any easy patterns:

![image](https://user-images.githubusercontent.com/49762827/215320605-90c51dff-7f2a-4b42-ac0c-de6eaa1a0d21.png)

Nothing of relevence in there.

Nothing was revealed in strings, so opening it up in Ghidra and inspecting the decompiled code I reached the conclusion that the ransomware reads in a file, allocates 
a buffer the length of the file, then performs a for loop going through each bit of the file, performs an XOR function, then a bitshift. 

Finally, it writes the buffer to a file, flag.enc!

Here is my annotated decompilation:

![image](https://user-images.githubusercontent.com/49762827/215282078-7f241404-030f-439a-952f-9167ae30fd63.png)

Alongside this, I have produced a small C++ file testing the output of rand, with and without srand to fully understand what is happening as I go through:

![image](https://user-images.githubusercontent.com/49762827/215282422-76e4d1aa-cff7-44b8-9557-cad0daba999d.png)

The next step which I will look at soon is to undo the encryption pattern in the for loop, which should in theory print out the flag!

# Building my own crypter

To figure out exactly what is going on, I've decided to reproduce this particualr part of the code, the first half of the for loop has been reengineered, I just need to look at the bitwise operation.

![image](https://user-images.githubusercontent.com/49762827/215323726-ee24c3b5-86a0-49a7-bcae-babaff83098c.png)

I think it's fairly obvious from this stage that the key to this is being able to find the correct seed to use in srand, as from my testing (I think) this should produce the same random values.

With this in mind I have taken a closer look at the encrypted file, first with just `test_file` as the content of the file, and second with `test_filessssssssss` as the content. Interestingly, this has revealed 4 bytes at the start of the file for each - an educated guess is that is the salt.

![image](https://user-images.githubusercontent.com/49762827/215324511-34985741-8ee2-4441-a0b7-b7182617a406.png)

Now I have an idea where I need to be focusing my investigation, I have outputted the result of the final operation in the for loop, and I can see how this matches up with the encrypted file - at this point though I have noticed this doesnt cover the first for bytes of the file (I also checked the last few letters, but havent included that screenshot, I did that as some letters arent outputting to the console, probably a characterset issue).

![image](https://user-images.githubusercontent.com/49762827/215325289-f07d58d8-ba76-4d1a-909b-24cc5cb58a24.png)

Going back to the decompiler to find these rogue 4 bytes and still perplexed how the seed even makes it into the file from the ROL operations, I can see that after the for loop (encryption process) is completed the seed is written to the file over 4 bytes! Doh!!

![image](https://user-images.githubusercontent.com/49762827/215325454-90dfcc0e-fb1c-4624-903b-355a534fc1d9.png)

I probably didn't need to reconstruct the encrypter, but I think it was valuable for me to do that anyway, and I find it is good practice to split a problem into smaller solvable chunks like this. It also helps me properly understand what the encryption pattern is so I can build a decrypter!

# The decrypter!

Now, I can make my decrypter which has to do the following things:

1) Read in the file
2) Take the first 4 bytes as the seed
3) Seed srand
4) Iterate the rest of the file and reverse the encryption process (and making sure the correct data types are used)
5) Output the result to the console, which should be the flag!

![image](https://user-images.githubusercontent.com/49762827/215349094-df492da4-e783-42fa-85cb-4107ccb65fb7.png)
