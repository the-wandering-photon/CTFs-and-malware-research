# 'Ransomware' decryptor!

This comes as an ELF file and a flag.enc, which is an encrypted file containing a flag, after being stuck with ransomware!

Taking a look at the .enc file with a hex editor, to see if there are any opportunities for a quick win, or to spot any easy patterns:

![image](https://user-images.githubusercontent.com/49762827/215320605-90c51dff-7f2a-4b42-ac0c-de6eaa1a0d21.png)

Nothing of relevence in there.

Nothing was revealed in strings, so opening it up in Ghidra and inspecting the decompiled code I reached the conclusion that the ransomware reads in a file, allocates 
a buffer the length of the file, then performs a for loop going through each bit of the file, performs an XOR function, then a bitshift. 

Finally, it writes the buffer to a file, flag.enc!

Here is my annotated decompilation:

![image](https://user-images.githubusercontent.com/49762827/215282078-7f241404-030f-439a-952f-9167ae30fd63.png)

Alongside this, I have produced a small C++ file testing the output of rand, with and without srand to fully understand what is happening as I go through:

![image](https://user-images.githubusercontent.com/49762827/215282422-76e4d1aa-cff7-44b8-9557-cad0daba999d.png)

The next step which I will look at soon is to undo the encryption pattern in the for loop, which should in theory print out the flag!

# Building my own crypter

To figure out exactly what is going on, I've decided to reproduce this particualr part of the code, the first half of the for loop has been reengineered, I just need to look at the bitwise operation.

![image](https://user-images.githubusercontent.com/49762827/215323726-ee24c3b5-86a0-49a7-bcae-babaff83098c.png)

